\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TTC 2015} % Name of the event you are submitting to
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{flafter}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{url}
\usepackage{color}

%ATL language highlighting
\lstdefinelanguage{atl}
{
  sensitive=true,
  morecomment=[l]{--},
  morestring=[b]',
  classoffset=0,
  morekeywords={module, create, from, to, using, mapsTo, rule, helper, refining,
                 context, def, if, then, else, endif, library, and, or, not, query, 
                 do, endpoint, entrypoint, lazy, unique, nodefault, for, in, self,
                 thisModule, uses},
  classoffset=1,
  morekeywords={Integer,Real,String,Boolean,Collection,Bag,Set,OrderedSet,Sequence,Map,Tuple,TupleType}
}

\definecolor{commentgreen}{rgb}{0.0, 0.4, 0.1}
\definecolor{commentblue}{rgb}{0.0, 0.1, 0.4}
\definecolor{typegreen}{rgb}{0.0, 0.6, 0.0}
\definecolor{keywordred}{rgb}{0.4, 0.0, 0.1}

%Standard listing style
\lstset{
  tabsize=2,
  basicstyle=\scriptsize\tt,
  commentstyle=\scriptsize\tt\color{commentblue},
  stringstyle=\scriptsize\tt\color{blue},
  classoffset=0,
  keywordstyle=\scriptsize\tt\bf\color{keywordred},
  classoffset=1,
  keywordstyle=\scriptsize\tt\color{typegreen},
  classoffset=0 % restore default
}

\title{The {ATL} Solution to the Train Benchmark Case for {TTC2015}}
\author{Dennis Wagelaar
\institute{HealthConnect\\
Vilvoorde, Belgium}
\email{dennis.wagelaar@healthconnect.be}
\and
Fr\'{e}d\'{e}ric Jouault
\institute{ESEO-Tech\\
Angers, France}
\email{Frederic.Jouault@eseo.fr}
}
\def\titlerunning{The {ATL} Solution to the Train Benchmark Case for {TTC2015}}
\def\authorrunning{D. Wagelaar, F. Jouault}
\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
\label{sec:intro}

This paper describes the ATL~\cite{journal/scp/Jouault2008} solution of the TTC 2015 Train Benchmark Case~\cite{conf/ttc/Szarnyas2015}. The Train Benchmark Case consists of several model validation and model repair tasks, all of which are run again increasing model sizes in order to measure the performance of each solution for the case. A complete solution for all tasks is provided, and is available as a GitHub fork of the original assignment\footnote{\url{https://github.com/dwagelaar/trainbenchmark-ttc}}.

The remainder of this paper is structured as follows: section~\ref{sec:atl} describes the ATL transformation tool and its features that are relevant to the case. Section~\ref{sec:solution} describes the solution to the case, and section~\ref{sec:eval} concludes this paper with an evaluation.

\section{ATL}
\label{sec:atl} 

ATL is a rule-based, hybrid model transformation language that allows declarative as well as imperative transformation styles. For this TTC solution, we use the new EMF Transformation Virtual Machine (EMFTVM)~\cite{conf/models/Wagelaar2011}. EMFTVM includes a number of language enhancements, as well as performance enhancements. For this TTC case, specific performance enhancements are relevant. Each of these enhancements is described briefly in the following subsections.

\subsection{JIT compiler}

EMFTVM includes a Just-In-Time (JIT) compiler that translates EMFTVM bytecode to Java bytecode. EMFTVM bytecode instructions are organised in \emph{code blocks} (see Fig.~\ref{fig:emftvm-rules}). Code blocks are executable lists of instructions, and have a number of local variables and a local stack space. Code blocks are used to represent operation bodies, field initialisers, rule guards, and rule bodies. Code blocks may also have nested code blocks, which effectively represent \emph{closures}\footnote{\url{http://en.wikipedia.org/wiki/Closure\_(computer_programming)}}. EMFTVM records how often each code block is executed, as well as some execution metadata, such as which methods were dispatched in each virtual method call. When a code block is executed more often than a predefined threshold, the JIT compiler triggers, and will generate a Java bytecode equivalent for the EMFTVM code block. The JIT compiler provides the best performance improvement for large and complex code blocks.

\begin{figure}[ht]
\centerline{
\includegraphics[width=12cm]{figures/emftvm-rules-stripped}}
\caption{Structure of EMFTVM rules and code blocks}
\label{fig:emftvm-rules}
\end{figure}

\subsection{Lazy evaluation}

EMFTVM includes an implementation of the OCL 2.2 standard library~\cite{omg/ocl22}, and employs lazy evaluation for the collection operations\footnote{\url{https://wiki.eclipse.org/ATL/EMFTVM\#Lazy\_collections}} (e.g. \texttt{select}, \texttt{collect}, \texttt{flatten}, \texttt{isEmpty}, etc.). That means you can invoke operations on the collections, but those operations will not be executed until you actually evaluate the collection. Also, collection operations will only be evaluated partially, depending on how much of the collection you evaluate. To illustrate how this works, look at the example code in Listing~\ref{lst:lazy}. The \texttt{lazytest} query invokes "collect" on a Sequence of all numbers from 0 to 100, and replaces each value in the Sequence by its squared value. Finally, we're only interested in the last value of the changed Sequence. \texttt{collect} returns a lazy Sequence, which is just waiting to be evaluated. Only when "last" is invoked on the lazy Sequence will the Sequence invoke the "expensive" operation on the last element of the input Sequence. As a result, \texttt{square} is only invoked once.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={Lazy collections in ATL}, label=lst:lazy, captionpos=b, frame=tb, belowskip=-10pt]
query lazytest = Sequence{0..100}->collect(x | x.square())->last();

helper context Integer def : square() : Integer =
	(self * self).debug('square');
\end{lstlisting}

In addition, short-circuit evaluation is applied to boolean expressions (i.e. \textbf{and}, \textbf{or}, and \textbf{not}). While this may not be a desirable semantics for OCL in general, it is advantageous for using OCL as a navigation language: only the relevant parts of the model are navigated. Lazy evaluation provides the best performance improvement when only consuming a small part of a string of collection operations (e.g. \texttt{list->reject(x | x.attr.oclIsUndefined())->collect(x | x.attr)->first()}). Short-\\circuit evaluation prevents having to use (nested) \texttt{if-then-else-endif} blocks everywhere.

\subsection{Caching of model elements}

Model transformations usually look up model elements by their type or meta-class. In the Eclipse Modeling Framework (EMF)~\cite{book/Budinsky03}, this means iterating over the entire model and filtering on element type. Often, an element look up by type is made repeatedly on the same model (especially when doing recursive, in-place transformation\footnote{\url{https://code.google.com/a/eclipselabs.org/p/simplegt/}}). In the case of this benchmark, the same query/transformation is run multiple times on the same model. For this reason, EMFTVM keeps a cache of model elements by type for each model. This cache is automatically kept up to date when adding/removing model elements through EMFTVM. The cache is built up lazily, which means that a full iteration over the model, looking for a specific element type, must have taken place before the cache is activated for that element type. This prevents a build up of caches that are never used.

\section{Solution Description}
\label{sec:solution}

The Train Benchmark Case involves first querying a model for constraint violations, and then repairing some of those constraint violations that are randomly selected by the benchmark framework. This means that the matching phase and the transformation phase, which are normally integrated in ATL, are now separated by the benchmark framework. The framework first launches the matching phase, and collects the found matches. After that, it randomly selects a number of matches, and feeds them into the transformation phase.

ATL provides a \textbf{query} construct that allows one to query the model using OCL. The resulting values are returned by the ATL VM. The selected matches are fed back into the ATL VM through a helper attribute, specified in the framework repair transformation module shown in Listing~\ref{lst:repair}. Note that the ATL query returns a \emph{lazy} collection, which is just waiting to be evaluated. The benchmark framework compensates for this by copying all values of the returned lazy collection into a regular \texttt{java.util.ArrayList}, which triggers evaluation. This ensures that the performance measurements are valid.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={Framework repair transformation module in ATL}, label=lst:repair, captionpos=b, frame=tb, belowskip=-10pt]
module Repair;
create OUT: RAILWAY refining IN: RAILWAY;

--- Helper attribute that holds the matches to transform.
--- Injected from outside the transformation.
helper def : matches : Collection(OclAny) = Sequence{};

--- Base implementation of the Repair rule that does nothing.
lazy rule Repair {
	from
		s: OclAny
}

--- Applies the Repair rule to all matches.
endpoint rule Main() {
	do {
		for (s in thisModule.matches) {
			thisModule.Repair(s);
		}
	}
}
\end{lstlisting}

The Repair transformation module contains a helper attribute \texttt{matches}, which is used to inject the matches selected by the benchmark framework. Furthermore, it contains a lazy rule \texttt{Repair}, which does nothing in this framework transformation. The \texttt{Repair} rule is invoked by every element in \texttt{matches} by the \texttt{Main} endpoint rule. The \texttt{Main} endpoint rule is automatically invoked. Normally, ATL transformations use matched rules that are automatically triggered for all matching elements in the input model(s). However, this benchmark requires the elements to transform to be set explicitly. Hence the need for this framework transformation module. All specific repair transformation modules are \emph{superimposed}~\cite{journal/sosym/Wagelaar2009} onto the framework transformation module, and redefine the \texttt{Repair} rule. This means that for each task we only need to define an ATL query and a \texttt{Repair} rule. The Java code in the benchmark plug-in for ATL is made up of a base class \texttt{ATLBenchmarkCase} that provides the generic logic for:

\begin{enumerate}
\item instantiating a query VM, a transformation VM, and loading the metamodels (\texttt{init});
\item loading the models (\texttt{read});
\item performing the query phase of the benchmark (\texttt{check});
\item performing the transformation phase of the benchmark (\texttt{modify}).
\end{enumerate}

Each specific task subclasses the \texttt{ATLBenchmarkCase} class, but only has to override the \texttt{init} method. The overridden \texttt{init} does all of the superclass \texttt{init}, but also loads the ATL transformation bytecode into the query VM and the transformation VM.

\subsection{Task 1: PosLength}

The PosLength task consists of a query that checks for Segments with a length less than or equal to zero, and a repair transformation that updates the length attribute of the segment in the match to \texttt{−length+1}. 

Listing~\ref{lst:poslength} shows the ATL query for Poslength. It simply collects all Segment instances with a length of zero or smaller.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={PosLength query in ATL}, label=lst:poslength, captionpos=b, frame=tb, belowskip=-10pt]
query PosLength = RAILWAY!Segment.allInstances()->select(s | s.length <= 0);
\end{lstlisting}

Listing~\ref{lst:poslengthrepair} shows the ATL repair transformation module for Poslength. It imports the framework Repair transformation module from Listing~\ref{lst:repair}, and redefines the \texttt{Repair} rule. As no new elements need to be created, and no implicit tracing of source elements to target elements is required, an imperative \textbf{do} block is used to make the required modification directly on the source element. The \texttt{<:=} assignment operator is used instead of the \texttt{<-} binding operator, such that the implicit source-to-target tracing is skipped.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={PosLength repair transformation module in ATL}, label=lst:poslengthrepair, captionpos=b, frame=tb, belowskip=-10pt]
module PosLengthRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s: RAILWAY!Segment
	do {
		s.length <:= -s.length + 1;
	}
}
\end{lstlisting}

\subsection{Task 2: SwitchSensor}

The SwitchSensor task consists of a query that checks for Switches that are not connected to a Sensor, and a repair transformation that creates and connects a new Sensor. 

Listing~\ref{lst:switchsensor} shows the ATL query for SwitchSensor. It collects all Switch instances for which the sensor is not set.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SwitchSensor query in ATL}, label=lst:switchsensor, captionpos=b, frame=tb, belowskip=-10pt]
query SwitchSensor = RAILWAY!Switch.allInstances()->select(s | s.sensor.oclIsUndefined());
\end{lstlisting}

Listing~\ref{lst:switchsensorrepair} shows the ATL repair transformation module for SwitchSensor. This time, the \texttt{Repair} rule also contains a \textbf{to} section that creates a new Sensor instance \texttt{se}. In the \textbf{do} section, this Sensor is assigned to the sensor reference of the input Switch element.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SwitchSensor repair transformation module in ATL}, label=lst:switchsensorrepair, captionpos=b, frame=tb, belowskip=-10pt]
module SwitchSensorRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s: RAILWAY!Switch
	to
		se: RAILWAY!Sensor
	do {
		s.sensor <:= se;
	}
}
\end{lstlisting}

\subsection{Task 3: SwitchSet}

The SwitchSet task consists of a query that checks for Routes that are not connected to a Sensor, which have a semaphore that show the GO signal. Additionally, the route follows a switch position (p) that is connected to a switch (sw), but the switch position (p.position) defines a different position from the current position of the switch (sw.currentPosition). Furthermore, a repair transformation is provided, which sets the currentPosition attribute of the switch to the position of the switchPosition. 

Listing~\ref{lst:switchset} shows the ATL query for SwitchSet. This query is more complex, and uses two helper attributes, \texttt{goRoutes} and \texttt{wrongSwitchPositions}, to spread the complexity. The main query collects Tuples of each match, where a match is defined by Route \texttt{r}, Semaphore \texttt{s}, SwitchPosition \texttt{p}, and Switch \texttt{sw}. A Tuple is created for each wrong SwitchPosition that was found for each Route with a ``GO'' signal. As one can see, Tuples allow for returning matches with multiple elements to the benchmark framework.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SwitchSet query in ATL}, label=lst:switchset, captionpos=b, frame=tb, belowskip=-10pt]
query SwitchSet = thisModule.goRoutes
	->collect(r | r.wrongSwitchPositions
		->collect(p | 
			Tuple{r = r, s = r.entry, p = p, sw = p.switch}
		)
	)
	->flatten();

--- Returns all Routes with a #GO signal on the entry Semaphore.
helper def : goRoutes : Sequence(RAILWAY!Route) =
	RAILWAY!Route.allInstances()->select(r | 
		not r.entry.oclIsUndefined() and r.entry.signal = #GO
	);

--- Returns all wrong SwitchPositions for the given Route.
helper context RAILWAY!Route 
def : wrongSwitchPositions : Sequence(RAILWAY!SwitchPosition) =
	self.follows->select(p | 
		not p.switch.oclIsUndefined() and p.switch.currentPosition <> p.position
	);
\end{lstlisting}

Listing~\ref{lst:switchsetrepair} shows the ATL repair transformation module for SwitchSet. The \texttt{Repair} rule takes the Tuple match as input element this time, and assigns the SwitchPosition's position to the Switch's currentPosition.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SwitchSet repair transformation module in ATL}, label=lst:switchsetrepair, captionpos=b, frame=tb, belowskip=-10pt]
module SwitchSetRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s : TupleType(
			r : RAILWAY!Route, 
			s : RAILWAY!Semaphore, 
			p : RAILWAY!SwitchPosition, 
			sw : RAILWAY!Switch)
	do {
		s.sw.currentPosition <:= s.p.position;
	}
}
\end{lstlisting}

\subsection{Extension Task 1: RouteSensor}

The RouteSensor task consists of a query that checks for Sensors that are connected to a Switch, but the Sensor and the Switch are not connected to the same Route. The repair transformation inserts the missing definedBy Sensors for the Route. 

Listing~\ref{lst:routesensor} shows the ATL query for RouteSensor. This query uses two helper attributes, \texttt{routes\-With\-Sensors} and \texttt{wrongSwitchPositions}, to spread the complexity. The main query collects Tuples  of each match, where a match is defined by Route \texttt{r}, SwitchPosition \texttt{p}, Switch \texttt{sw}, and Sensor \texttt{s}. A Tuple is created for each SwitchPosition connected to a Sensor that is not connected to the Route (\texttt{wrongSwitchPositions}), for each Route that has Sensors connected to it (\texttt{routesWithSensors}). 

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={RouteSensor query in ATL}, label=lst:routesensor, captionpos=b, frame=tb, belowskip=-10pt]
query RouteSensor = thisModule.routesWithSensors
	->collect(r | r.wrongSwitchPositions
		->collect(p | 
			Tuple{r = r, p = p, sw = p.switch, s = p.switch.sensor}
		)
	)
	->flatten();

--- Returns all Routes with Sensors.
helper def : routesWithSensors : Sequence(RAILWAY!Route) =
	RAILWAY!Route.allInstances()->select(r | r.definedBy->notEmpty());

--- Returns all wrong SwitchPositions for the given Route.
helper context RAILWAY!Route 
def : wrongSwitchPositions : Sequence(RAILWAY!SwitchPosition) =
	self.follows->select(p | 
		let switch : RAILWAY!Switch = p.switch in
		not switch.oclIsUndefined() and 
		not switch.sensor.oclIsUndefined() and
		self.definedBy->excludes(switch.sensor)
	);
\end{lstlisting}

Listing~\ref{lst:routesensorrepair} shows the ATL repair transformation module for RouteSensor. The \texttt{Repair} rule takes the Tuple match as input element, and adds the Sensor in the match to the Route's definedBy sensors.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={RouteSensor repair transformation module in ATL}, label=lst:routesensorrepair, captionpos=b, frame=tb, belowskip=-10pt]
module RouteSensorRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s : TupleType(
			r : RAILWAY!Route, 
			p : RAILWAY!SwitchPosition, 
			sw : RAILWAY!Switch,
			s : RAILWAY!Sensor)
	do {
		s.r.definedBy <:= s.r.definedBy->including(s.s);
	}
}
\end{lstlisting}

\subsection{Extension Task 2: SemaphoreNeighbor}

The SemaphoreNeighbor task consists of a query that checks for Routes \texttt{r1} that have an exit Semaphore, and a Sensor \texttt{s1} connected to another Sensor \texttt{s2} -- defining another Route \texttt{r3} -- by two TrackElements \texttt{te1} and \texttt{te2}, for which there is no other Route \texttt{r2} that connects the same Semaphore and the other Sensor \texttt{s2}. Furthermore, a repair transformation is provided, which removes the exit Semaphore from Route \texttt{r1}. 

Listing~\ref{lst:semaphoreneighbor} shows the ATL query for SemaphoreNeighbor. This query uses three helper attributes, \texttt{routesWithExitSemaphore}, \texttt{sensorTuples}, and \texttt{routesBySensor}, to spread the complexity. The main query collects the \texttt{sensorTuples} for each Route with an exit Semaphore, and flattens the resulting Sets into a single Set of Tuples. The \texttt{sensorTuples} helper collects the match Tuples, where a match is defined by Route \texttt{r1}, Sensor \texttt{s1}, TrackElement \texttt{te1}, TrackElement \texttt{te2}, Sensor \texttt{s2}, and Route \texttt{r3}. A Tuple is created for each Route \texttt{r3} that is different from Route \texttt{r1}, connected to Sensor \texttt{s2}, where \texttt{s2} is connected to Sensor \texttt{s1} or Route \texttt{r1} by TrackElements \texttt{te1} and \texttt{te2}. It uses the Object Indexing pattern~\cite{conf/icsea/Lano2011}, applied in the \texttt{routesBySensor} helper, to reduce the search space for matching Routes \texttt{r3}. This is achieved by pre-indexing all Routes by their definedBy Sensors. ATL/EMFTVM provides the \texttt{mappedBy} collection operation for this. 

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SemaphoreNeighbor query in ATL}, label=lst:semaphoreneighbor, captionpos=b, frame=tb, belowskip=-10pt]
query SemaphoreNeighbour = thisModule.routesWithExitSemaphore
	->collect(r | r.sensorTuples)
	->flatten();

--- Returns all Routes with exit Semaphore.
helper def : routesWithExitSemaphore : Sequence(RAILWAY!Route) =
	RAILWAY!Route.allInstances()->reject(r | r.exit.oclIsUndefined());

--- Returns the sensor tuples and their track elements that match the given route.
helper context RAILWAY!Route def : sensorTuples : Sequence(
		TupleType(
			r1 : RAILWAY!Route,
			s1 : RAILWAY!Sensor, 
			te1 : RAILWAY!TrackElement, 
			te2 : RAILWAY!TrackElement, 
			s2 : RAILWAY!Sensor,
			r3 : RAILWAY!Route)) =
	self.definedBy->collect(s1 | 
		s1.elements->collect(te1 | 
			te1.connectsTo->reject(te2 | 
				let s2 : RAILWAY!Sensor = te2.sensor in
				s2.oclIsUndefined() or (
					let s2routes : Set(RAILWAY!Route) = thisModule.routesBySensor.get(s2) in
					s2routes.oclIsUndefined() or
					s2routes->exists(r2 | r2.entry = self.exit)
				)
			)->collect(te2 |
				let s2 : RAILWAY!Sensor = te2.sensor in
				let s2routes : Set(RAILWAY!Route) = thisModule.routesBySensor.get(s2) in
				s2routes->select(r3 |
					r3 <> self and r3.definedBy->includes(s2)
				)->collect(r3 |
					Tuple{r1 = self, s1 = s1, te1 = te1, te2 = te2, s2 = s2, r3 = r3}
				)
			)
		)
	)->flatten();

--- Returns the Routes mapped by their Sensor.
helper def : routesBySensor : Map(RAILWAY!Sensor, Set(RAILWAY!Route)) =
	RAILWAY!Route.allInstances()->mappedBy(e | e.definedBy);
\end{lstlisting}

Listing~\ref{lst:semaphoreneighborrepair} shows the ATL repair transformation module for SemaphoreNeighbor. The \texttt{Repair} rule takes the Tuple match as input element, and removes the exit Semaphore from Route \texttt{r1}.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SemaphoreNeighbor repair transformation module in ATL}, label=lst:semaphoreneighborrepair, captionpos=b, frame=tb, belowskip=-10pt]
module SemaphoreNeighbourRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s : TupleType(
			r1 : RAILWAY!Route,
			s1 : RAILWAY!Sensor, 
			te1 : RAILWAY!TrackElement, 
			te2 : RAILWAY!TrackElement, 
			s2 : RAILWAY!Sensor,
			r3 : RAILWAY!Route)
	do {
		s.r1.exit <:= OclUndefined;
	}
}
\end{lstlisting}

\section{Evaluation and Conclusion}
\label{sec:eval}

The solutions for the Train Benchmark Case are evaluated on three criteria: (1) \emph{Correctness and Completeness of Model Queries and Transformations}, (2) \emph{Applicability for Model Validation}, and (3) \emph{Performance on Large Models}. We will now discuss how the ATL solution aims to meet these criteria.

\subsection{Correctness and Completeness}

The benchmark framework provides a set of expected query/transformation results, against which the output of the ATL solution can be compared. The \texttt{ATLTest} JUnit test case verifies that the output of the ATL solution matches the reference solution. The test results of each build are kept in the cloud-based Travis continuous integration platform\footnote{\url{https://travis-ci.org/dwagelaar/trainbenchmark-ttc}}. This independent platform provides an objective proof that the ATL solution unit tests are passing. Furthermore, all git commits for the ATL solution are publicly available on GitHub, and it can be verified that no modifications are made to the benchmark framework and/or the expected result set.

\subsection{Applicability}

In order for a solution to be applicable for model validation, it must be concise and maintainable. Even though ATL is not primarily intended for interactive querying and transformation, it was easy to fit the ATL implementation into the benchmark framework. Simple queries are trivially expressed in OCL, using a functional programming style (PosLength, SwitchSensor). Complex queries that return tuples as matches (SwitchSet, RouteSensor, SemaphoreNeighbor) require a navigation strategy to be implemented. While this is not as declarative as first-class patterns, it is more concise than imperative programming. Also, ATL provides helper attributes and operations to divide the complexity into modular blocks.

All transformations are all simple, single rule transformation modules that are \emph{superimposed} onto a single framework Repair transformation module (see Listing~\ref{lst:repair}). Query matches are provided via the rule \textbf{from} part, whereas the model element modification is done in a \textbf{do} block. Any new elements are specified in the \textbf{to} block.

Most example and production ATL transformation modules are much longer than the ones used in the benchmark case solution\footnote{\url{https://www.eclipse.org/atl/atlTransformations/}}, with industrial cases going up to 7000 lines of ATL for a single transformation scenario\footnote{\url{http://www.slideshare.net/DennisWagelaar/wagelaar-sda2014}}. Even such long transformation modules have proven to be sufficiently maintainable, especially when compared to implementations in Java.

\subsection{Performance}

The benchmark framework supports running the solution against increasing model sizes, starting at $2^0$ and going up by $2^{n+1}$. Within the memory constraints of the SHARE image\footnote{\url{http://is.ieis.tue.nl/staff/pvgorp/share/?trgPage=LookupImage&vdiNameSearch=TTC15_ATL}} of 1 GB RAM, we managed to go up to model size 512 with \texttt{-Xmx512m} as JVM arguments. While all benchmark tasks can be completed on SHARE for this model size within the time constraint of 5 minutes, this does not work all of the time. The performance of a SHARE VM is not consistent, and we sometimes saw simple tasks time out (e.g. RouteSensor, SwitchSensor), while the most complex task (SemaphoreNeighbor) finishes. On local hardware (AMD 1055T\footnote{\url{http://www.cpubenchmark.net/cpu.php?cpu=AMD+Phenom+II+X6+1055T}}), with 8 GB RAM and using \texttt{-Xmx4G} as JVM arguments (\texttt{java-1.7.0-openjdk-1.7.0.79-2.5.5.0.fc20.x86\_64}), we managed to go up to model size 4096 without a single time-out.

Performance in using the ATL language is achieved by using helper attributes instead of operations where possible, as helper attribute values are cached; accessing a helper attribute more than once on the same object will not trigger evaluation again, but just returns the cached value. In addition, design patterns specific to model transformation, such as the Object Indexing pattern~\cite{conf/icsea/Lano2011} can be used to reduce the search space for a given model element.

Furthermore, the virtual machine (EMFTVM) also applies certain performance optimisations. Complex code blocks are JIT-compiled to Java bytecode, which in turn may be JIT-compiled to native code by the JVM. Collections and boolean expressions are evaluated lazily, preventing unnecessary navigation and allowing short-circuit evaluation of expressions. Finally, model elements are cached by their type, making repeated lookup of all instances of a certain metaclass more performant.

\bibliographystyle{eptcs}
\bibliography{ttc15-atl}
\end{document}
