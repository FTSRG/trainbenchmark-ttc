\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TTC 2015} % Name of the event you are submitting to
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{flafter}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{url}
\usepackage{color}

%ATL language highlighting
\lstdefinelanguage{atl}
{
  sensitive=true,
  morecomment=[l]{--},
  morestring=[b]',
  classoffset=0,
  morekeywords={module, create, from, to, using, mapsTo, rule, helper, refining,
                 context, def, if, then, else, endif, library, and, or, not, query, 
                 do, endpoint, entrypoint, lazy, unique, nodefault, for, in, self,
                 thisModule, uses},
  classoffset=1,
  morekeywords={Integer,Real,String,Boolean,Collection,Bag,Set,OrderedSet,Sequence,Map,Tuple,TupleType}
}

\definecolor{commentgreen}{rgb}{0.0, 0.4, 0.1}
\definecolor{commentblue}{rgb}{0.0, 0.1, 0.4}
\definecolor{typegreen}{rgb}{0.0, 0.6, 0.0}
\definecolor{keywordred}{rgb}{0.4, 0.0, 0.1}

%Standard listing style
\lstset{
  tabsize=2,
  basicstyle=\scriptsize\tt,
  commentstyle=\scriptsize\tt\color{commentblue},
  stringstyle=\scriptsize\tt\color{blue},
  classoffset=0,
  keywordstyle=\scriptsize\tt\bf\color{keywordred},
  classoffset=1,
  keywordstyle=\scriptsize\tt\color{typegreen},
  classoffset=0 % restore default
}

\title{The {ATL} Solution to the Train Benchmark Case for {TTC2015}}
\author{Dennis Wagelaar
\institute{HealthConnect\\
Vilvoorde, Belgium}
\email{dennis.wagelaar@healthconnect.be}
\and
Fr\'{e}d\'{e}ric Jouault
\institute{ESEO-Tech\\
Angers, France}
\email{Frederic.Jouault@eseo.fr}
}
\def\titlerunning{The {ATL} Solution to the Train Benchmark Case for {TTC2015}}
\def\authorrunning{D. Wagelaar, F. Jouault}
\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
\label{sec:intro}

This paper describes the ATL~\cite{journal/scp/Jouault2008} solution of the TTC 2015 Train Benchmark Case~\cite{conf/ttc/Szarnyas2015}. The Train Benchmark Case consists of several model validation and model repair tasks, all of which are run again increasing model sizes in order to measure the performance of each solution for the case. A complete solution for all tasks is provided, and is available as a GitHub fork of the original assignment\footnote{\url{https://github.com/dwagelaar/trainbenchmark-ttc}}.

The remainder of this paper is structured as follows: section~\ref{sec:atl} describes the ATL transformation tool and its features that are relevant to the case. Section~\ref{sec:solution} describes the solution to the case, and section~\ref{sec:eval} concludes this paper with an evaluation.

\section{ATL}
\label{sec:atl} 

ATL is a rule-based, hybrid model transformation language that allows declarative as well as imperative transformation styles. For this TTC solution, we use the new EMF Transformation Virtual Machine (EMFTVM)~\cite{conf/models/Wagelaar2011}. EMFTVM includes a number of language enhancements, as well as performance enhancements. For this TTC case, specific performance enhancements are relevant. Each of these enhancements is described briefly in the following subsections.

\subsection{JIT compiler}

EMFTVM includes a Just-In-Time (JIT) compiler that translates EMFTVM bytecode to Java bytecode. EMFTVM bytecode instructions are organised in \emph{code blocks} (see Fig.~\ref{fig:emftvm-rules}). Code blocks are executable lists of instructions, and have a number of local variables and a local stack space. Code blocks are used to represent operation bodies, field initialisers, rule guards, and rule bodies. Code blocks may also have nested code blocks, which effectively represent \emph{closures}\footnote{\url{http://en.wikipedia.org/wiki/Closure\_(computer_programming)}}. EMFTVM records how often each code block is executed, as well as some execution metadata, such as which methods were dispatched in each virtual method call. When a code block is executed more often than a predefined threshold, the JIT compiler triggers, and will generate a Java bytecode equivalent for the EMFTVM code block. The JIT compiler provides the best performance improvement for large and complex code blocks.

\begin{figure}[ht]
\centerline{
\includegraphics[width=12cm]{figures/emftvm-rules-stripped}}
\caption{Structure of EMFTVM rules and code blocks}
\label{fig:emftvm-rules}
\end{figure}

\subsection{Lazy evaluation}

EMFTVM includes an implementation of the OCL 2.2 standard library~\cite{omg/ocl22}, and employs lazy evaluation for the collection operations\footnote{\url{https://wiki.eclipse.org/ATL/EMFTVM\#Lazy\_collections}} (e.g. \texttt{select}, \texttt{collect}, \texttt{flatten}, \texttt{isEmpty}, etc.). That means you can invoke operations on the collections, but those operations will not be executed until you actually evaluate the collection. Also, collection operations will only be evaluated partially, depending on how much of the collection you evaluate. To illustrate how this works, look at the example code in Listing~\ref{lst:lazy}. The \texttt{lazytest} query invokes "collect" on a Sequence of all numbers from 0 to 100, and replaces each value in the Sequence by its squared value. Finally, we're only interested in the last value of the changed Sequence. \texttt{collect} returns a lazy Sequence, which is just waiting to be evaluated. Only when "last" is invoked on the lazy Sequence will the Sequence invoke the "expensive" operation on the last element of the input Sequence. As a result, \texttt{square} is only invoked once.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={Lazy collections in ATL}, label=lst:lazy, captionpos=b, frame=tb, belowskip=-10pt]
query lazytest = Sequence{0..100}->collect(x | x.square())->last();

helper context Integer def : square() : Integer =
	(self * self).debug('square');
\end{lstlisting}

In addition, short-circuit evaluation is applied to boolean expressions (i.e. \textbf{and}, \textbf{or}, and \textbf{not}). While this may not be a desirable semantics for OCL in general, it is advantageous for using OCL as a navigation language: only the relevant parts of the model are navigated. Lazy evaluation provides the best performance improvement when only consuming a small part of a string of collection operations (e.g. \texttt{list->reject(x | x.attr.oclIsUndefined())->collect(x | x.attr)->first()}). Short-\\circuit evaluation prevents having to use (nested) \texttt{if-then-else-endif} blocks everywhere.

\section{Solution Description}
\label{sec:solution}

The Train Benchmark Case involves first querying a model for constraint violations, and then repairing some of those constraint violations that are randomly selected by the benchmark framework. This means that the matching phase and the transformation phase, which are normally integrated in ATL, are now separated by the benchmark framework. The framework first launches the matching phase, and collects the found matches. After that, it randomly selects a number of matches, and feeds them into the transformation phase.

ATL provides a \textbf{query} construct that allows one to query the model using OCL. The resulting values are returned by the ATL VM. The selected matches are fed back into the ATL VM through a helper attribute, specified in the framework repair transformation module shown in Listing~\ref{lst:repair}.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={Framework repair transformation module in ATL}, label=lst:repair, captionpos=b, frame=tb, belowskip=-10pt]
module Repair;
create OUT: RAILWAY refining IN: RAILWAY;

--- Helper attribute that holds the matches to transform.
--- Injected from outside the transformation.
helper def : matches : Collection(OclAny) = Sequence{};

--- Base implementation of the Repair rule that does nothing.
lazy rule Repair {
	from
		s: OclAny
}

--- Applies the Repair rule to all matches.
endpoint rule Main() {
	do {
		for (s in thisModule.matches) {
			thisModule.Repair(s);
		}
	}
}
\end{lstlisting}

The Repair transformation module contains a helper attribute \texttt{matches}, which is used to inject the matches selected by the benchmark framework. Furthermore, it contains a lazy rule \texttt{Repair}, which does nothing in this framework transformation. The \texttt{Repair} rule is invoked by every element in \texttt{matches} by the \texttt{Main} endpoint rule. The \texttt{Main} endpoint rule is automatically invoked. Normally, ATL transformations use matched rules that are automatically triggered for all matching elements in the input model(s). However, this benchmark requires the elements to transform to be set explicitly. Hence the need for this framework transformation module. All specific repair transformation modules are superimposed~\cite{journal/sosym/Wagelaar2009} onto the framework transformation module, and redefine the \texttt{Repair} rule. This means that for each task we only need to define an ATL query and a \texttt{Repair} rule. The Java code in the benchmark plug-in for ATL is made up of a base class \texttt{ATLBenchmarkCase} that provides the generic logic for:

\begin{enumerate}
\item instantiating a query VM, a transformation VM, and loading the metamodels (\texttt{init});
\item loading the models (\texttt{read});
\item performing the query phase of the benchmark (\texttt{check});
\item performing the transformation phase of the benchmark (\texttt{modify}).
\end{enumerate}

Each specific task subclasses the \texttt{ATLBenchmarkCase} class, but only has to override the \texttt{init} method. The overridden \texttt{init} does all of the superclass \texttt{init}, but also loads the ATL transformation bytecode into the query VM and the transformation VM.

\subsection{Task 1: PosLength}

The PosLength task consists of a query that checks for Segments with a length less than or equal to zero, and a repair transformation that updates the length attribute of the segment in the match to \texttt{âˆ’length+1}. 

Listing~\ref{lst:poslength} shows the ATL query for Poslength. It simply collects all Segment instances with a length of zero or smaller.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={PosLength query in ATL}, label=lst:poslength, captionpos=b, frame=tb, belowskip=-10pt]
query PosLength = RAILWAY!Segment.allInstances()->select(s | s.length <= 0);
\end{lstlisting}

Listing~\ref{lst:poslengthrepair} shows the ATL repair transformation module for Poslength. It imports the framework Repair transformation module from Listing~\ref{lst:repair}, and redefines the \texttt{Repair} rule. As no new elements need to be created, and no implicit tracing of source elements to target elements is required, an imperative \textbf{do} block is used to make the required modification directly on the source element. The \texttt{<:=} assignment operator is used instead of the \texttt{<-} binding operator, such that the implicit source-to-target tracing is skipped.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={PosLength repair transformation module in ATL}, label=lst:poslengthrepair, captionpos=b, frame=tb, belowskip=-10pt]
module PosLengthRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s: RAILWAY!Segment
	do {
		s.length <:= -s.length + 1;
	}
}
\end{lstlisting}

\subsection{Task 2: SwitchSensor}

The SwitchSensor task consists of a query that checks for Switches that are not connected to a Sensor, and a repair transformation that creates and connects a new Sensor. 

Listing~\ref{lst:switchsensor} shows the ATL query for SwitchSensor. It collects all Switch instances for which the sensor is not set.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SwitchSensor query in ATL}, label=lst:switchsensor, captionpos=b, frame=tb, belowskip=-10pt]
query SwitchSensor = RAILWAY!Switch.allInstances()->select(s | s.sensor.oclIsUndefined());
\end{lstlisting}

Listing~\ref{lst:switchsensorrepair} shows the ATL repair transformation module for SwitchSensor. This time, the \texttt{Repair} rule also contains a \textbf{to} section that creates a new Sensor instance \texttt{se}. In the \textbf{do} section, this Sensor is assigned to the sensor reference of the input Switch element.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SwitchSensor repair transformation module in ATL}, label=lst:switchsensorrepair, captionpos=b, frame=tb, belowskip=-10pt]
module SwitchSensorRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s: RAILWAY!Switch
	to
		se: RAILWAY!Sensor
	do {
		s.sensor <:= se;
	}
}
\end{lstlisting}

\subsection{Task 3: SwitchSet}

The SwitchSet task consists of a query that checks for Routes that are not connected to a Sensor, which have a semaphore that show the GO signal. Additionally, the route follows a switch position (p) that is connected to a switch (sw), but the switch position (p.position) defines a different position from the current position of the switch (sw.currentPosition). Furthermore, a repair transformation is provided, which sets the currentPosition attribute of the switch to the position of the switchPosition. 

Listing~\ref{lst:switchset} shows the ATL query for SwitchSet. This query is more complex, and uses two helper attributes, \texttt{goRoutes} and \texttt{wrongSwitchPositions}, to spread the complexity. The main query collects Tuples of each match, where a match is defined by Route \texttt{r}, Semaphore \texttt{s}, SwitchPosition \texttt{p}, and Switch \texttt{sw}. A Tuple is created for each wrong SwitchPosition that was found for each Route with a ``GO'' signal. As one can see, Tuples allow for returning matches with multiple elements to the benchmark framework.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SwitchSet query in ATL}, label=lst:switchset, captionpos=b, frame=tb, belowskip=-10pt]
query SwitchSet = thisModule.goRoutes
	->collect(r | r.wrongSwitchPositions
		->collect(p | 
			Tuple{r = r, s = r.entry, p = p, sw = p.switch}
		)
	)
	->flatten();

--- Returns all Routes with a #GO signal on the entry Semaphore.
helper def : goRoutes : Sequence(RAILWAY!Route) =
	RAILWAY!Route.allInstances()->select(r | 
		not r.entry.oclIsUndefined() and r.entry.signal = #GO
	);

--- Returns all wrong SwitchPositions for the given Route.
helper context RAILWAY!Route 
def : wrongSwitchPositions : Sequence(RAILWAY!SwitchPosition) =
	self.follows->select(p | 
		not p.switch.oclIsUndefined() and p.switch.currentPosition <> p.position
	);
\end{lstlisting}

Listing~\ref{lst:switchsetrepair} shows the ATL repair transformation module for SwitchSet. The \texttt{Repair} rule takes the Tuple match as input element this time, and assigns the SwitchPosition's position to the Switch's currentPosition.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SwitchSet repair transformation module in ATL}, label=lst:switchsetrepair, captionpos=b, frame=tb, belowskip=-10pt]
module SwitchSetRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s : TupleType(
			r : RAILWAY!Route, 
			s : RAILWAY!Semaphore, 
			p : RAILWAY!SwitchPosition, 
			sw : RAILWAY!Switch)
	do {
		s.sw.currentPosition <:= s.p.position;
	}
}
\end{lstlisting}

\subsection{Extension Task 1: RouteSensor}

The RouteSensor task consists of a query that checks for Sensors that are connected to a Switch, but the Sensor and the Switch are not connected to the same Route. The repair transformation inserts the missing definedBy Sensors for the Route. 

Listing~\ref{lst:routesensor} shows the ATL query for RouteSensor. This query uses two helper attributes, \texttt{routesWithSensors} and \texttt{wrongSwitchPositions}, to spread the complexity. The main query collects Tuples  of each match, where a match is defined by Route \texttt{r}, SwitchPosition \texttt{p}, Switch \texttt{sw}, and Sensor \texttt{s}. A Tuple is created for each SwitchPosition connected to a Sensor that is not connected to the Route (\texttt{wrongSwitchPositions}), for each Route that has Sensors connected to it (\texttt{routesWithSensors}). 

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={RouteSensor query in ATL}, label=lst:routesensor, captionpos=b, frame=tb, belowskip=-10pt]
query RouteSensor = thisModule.routesWithSensors
	->collect(r | r.wrongSwitchPositions
		->collect(p | 
			Tuple{r = r, p = p, sw = p.switch, s = p.switch.sensor}
		)
	)
	->flatten();

--- Returns all Routes with Sensors.
helper def : routesWithSensors : Sequence(RAILWAY!Route) =
	RAILWAY!Route.allInstances()->select(r | r.definedBy->notEmpty());

--- Returns all wrong SwitchPositions for the given Route.
helper context RAILWAY!Route 
def : wrongSwitchPositions : Sequence(RAILWAY!SwitchPosition) =
	self.follows->select(p | 
		let switch : RAILWAY!Switch = p.switch in
		not switch.oclIsUndefined() and 
		not switch.sensor.oclIsUndefined() and
		self.definedBy->excludes(switch.sensor)
	);
\end{lstlisting}

Listing~\ref{lst:routesensorrepair} shows the ATL repair transformation module for RouteSensor. The \texttt{Repair} rule takes the Tuple match as input element, and adds the Sensor in the match to the Route's definedBy sensors.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={RouteSensor repair transformation module in ATL}, label=lst:routesensorrepair, captionpos=b, frame=tb, belowskip=-10pt]
module RouteSensorRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s : TupleType(
			r : RAILWAY!Route, 
			p : RAILWAY!SwitchPosition, 
			sw : RAILWAY!Switch,
			s : RAILWAY!Sensor)
	do {
		s.r.definedBy <:= s.r.definedBy->including(s.s);
	}
}
\end{lstlisting}

\subsection{Extension Task 2: SemaphoreNeighbor}

The SemaphoreNeighbor task consists of a query that checks for Routes \texttt{r1} that have an exit Semaphore, and a Sensor \texttt{s1} connected to another Sensor \texttt{s2} -- defining another Route \texttt{r3} -- by two TrackElements \texttt{te1} and \texttt{te2}, for which there is no other Route \texttt{r2} that connects the same Semaphore and the other Sensor \texttt{s2}. Furthermore, a repair transformation is provided, which removes the exit Semaphore from Route \texttt{r1}. 

Listing~\ref{lst:semaphoreneighbor} shows the ATL query for SemaphoreNeighbor. This query uses three helper attributes, \texttt{routesWithExitSemaphore}, \texttt{sensorTuples}, and \texttt{routesBySensor}, to spread the complexity. The main query collects the \texttt{sensorTuples} for each Route with an exit Semaphore, and flattens the resulting Sets into a single Set of Tuples. The \texttt{sensorTuples} helper collects the match Tuples, where a match is defined by Route \texttt{r1}, Sensor \texttt{s1}, TrackElement \texttt{te1}, TrackElement \texttt{te2}, Sensor \texttt{s2}, and Route \texttt{r3}. A Tuple is created for each Route \texttt{r3} that is different from Route \texttt{r1}, connected to Sensor \texttt{s2}, where \texttt{s2} is connected to Sensor \texttt{s1} or Route \texttt{r1} by TrackElements \texttt{te1} and \texttt{te2}. It uses the Object Indexing pattern~\cite{conf/icsea/Lano2011}, applied in the \texttt{routesBySensor} helper, to reduce the search space for matching Routes \texttt{r3}. This is achieved by pre-indexing all Routes by their definedBy Sensors. ATL/EMFTVM provides the \texttt{mappedBy} collection operation for this. 

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SemaphoreNeighbor query in ATL}, label=lst:semaphoreneighbor, captionpos=b, frame=tb, belowskip=-10pt]
query SemaphoreNeighbour = thisModule.routesWithExitSemaphore
	->collect(r | r.sensorTuples)
	->flatten();

--- Returns all Routes with exit Semaphore.
helper def : routesWithExitSemaphore : Sequence(RAILWAY!Route) =
	RAILWAY!Route.allInstances()->reject(r | r.exit.oclIsUndefined());

--- Returns the sensor tuples and their track elements that match the given route.
helper context RAILWAY!Route def : sensorTuples : Set(
		TupleType(
			r1 : RAILWAY!Route,
			s1 : RAILWAY!Sensor, 
			te1 : RAILWAY!TrackElement, 
			te2 : RAILWAY!TrackElement, 
			s2 : RAILWAY!Sensor,
			r3 : RAILWAY!Route)) =
	self.definedBy->collect(s1 | 
		s1.elements->collect(te1 | 
			te1.connectsTo->reject(te2 | 
				let s2 : RAILWAY!Sensor = te2.sensor in
				s2.oclIsUndefined() or (
					let s2routes : Set(RAILWAY!Route) = thisModule.routesBySensor.get(s2) in
					s2routes.oclIsUndefined() or s2routes->isEmpty() or
					s2routes->exists(r2 | r2.entry = self.exit)
				)
			)->collect(te2 |
				let s2 : RAILWAY!Sensor = te2.sensor in
				let s2routes : Set(RAILWAY!Route) = thisModule.routesBySensor.get(s2) in
				s2routes->select(r3 |
					r3 <> self and r3.definedBy->includes(s2)
				)->collect(r3 |
					Tuple{r1 = self, s1 = s1, te1 = te1, te2 = te2, s2 = s2, r3 = r3}
				)
			)
		) 
	)->flatten();

--- Returns the Routes mapped by their Sensor.
helper def : routesBySensor : Map(RAILWAY!Sensor, Set(RAILWAY!Route)) =
	RAILWAY!Route.allInstances()->mappedBy(e | e.definedBy);
\end{lstlisting}

Listing~\ref{lst:semaphoreneighborrepair} shows the ATL repair transformation module for SemaphoreNeighbor. The \texttt{Repair} rule takes the Tuple match as input element, and removes the exit Semaphore from Route \texttt{r1}.

\lstset{language=atl}
\begin{lstlisting}[float=htb, caption={SemaphoreNeighbor repair transformation module in ATL}, label=lst:semaphoreneighborrepair, captionpos=b, frame=tb, belowskip=-10pt]
module SemaphoreNeighbourRepair;
create OUT: RAILWAY refining IN: RAILWAY;

uses Repair;

lazy rule Repair {
	from
		s : TupleType(
			r1 : RAILWAY!Route,
			s1 : RAILWAY!Sensor, 
			te1 : RAILWAY!TrackElement, 
			te2 : RAILWAY!TrackElement, 
			s2 : RAILWAY!Sensor,
			r3 : RAILWAY!Route)
	do {
		s.r1.exit <:= OclUndefined;
	}
}
\end{lstlisting}

\section{Evaluation and Conclusion}
\label{sec:eval}

\bibliographystyle{eptcs}
\bibliography{ttc15-atl}
\end{document}
